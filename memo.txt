delete-user

// Check if the post author is null

hot-boards

// Boards made yesterday that have more than 10 likes.

report-board

// Report board (Move to report table if report more than 5)

popular-board

// Boards with 5 likes within 1 hours

realtime-display-likes

// Show users real-time 'likes' increase using socket in NestJS.
// Step 1 : Broadcast likes increase.
// Step 2 : Connecting URL.

refactoring view board

// add 20 comments in response json data.

follow, unfollow

keyword hashtag, user tag

//

alarm

// 1. follow user post new board
// 2. test sse

sse 예제코드는 보니까 알겠는데, 웹소켓에서 실시간 푸시알림이 어떻게 진행되는지가 더 궁금해짐
로그인 시 미들웨어 Or jwtAuthGuard에서 sse에 등록(sseRepository에 유저 정보 삽입)
특정 클라이언트에게 알림을 보내야 할 떄, emit을 통해 특정 데이터를 보낸다.
클라이언트는 header와 같이 전반적인 페이지를 구성하고 있는 레이아웃에 해당 EventSource객체 생성한다.
웹클라이언트로 서버에서 다른 api를 호출할수 있다고 한다. 비동기라고 하니 찾아보자.
=> Spring전용인듯, 검색해보니 공식문서에는 axios를 사용한 예제가 있으니 이걸 사용해 보자.

글작성 -> 팔로워들에게 알림 보내기


게시글 신고 이유 추가해야겠다.

쪽지

//1. user를 profile과 activity로 나눈다.
//2. activity에 쪽지함을 추가 (ManyToMany)
//3. 쪽지를 보낼 경우 redis에 저장한다. key는 note엔티티에서 생성될 note${id}, value는 {from, to, content}
//4. 내용을 삭제해도 상대편에서 보내면 다시 생성될텐데 => 이거 로직좀 봐봐야될것같은데
//읽음이 확인되면 디비에서 지워도 되지 않을까
//

조회수도 redis에 저장한다음에 write-back 할 수 있겠다.